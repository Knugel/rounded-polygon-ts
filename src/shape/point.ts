import { interpolate } from "./utils";

export type PointTransformer = (x: number, y: number) => Point;

export class Point {
    constructor(public x: number, public y: number) { }

    public copy(x: number = this.x, y: number = this.y) {
        return new Point(x, y);
    }

    /**
     * The magnitude of the Point, which is the distance of this point from (0, 0).
     *
     * If you need this value to compare it to another [Point]'s distance, consider using
     * [getDistanceSquared] instead, since it is cheaper to compute.
     */
    public getDistance(): number {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    /**
     * The square of the magnitude (which is the distance of this point from (0, 0)) of the Point.
     *
     * This is cheaper than computing the [getDistance] itself.
     */
    public getDistanceSquared(): number {
        return this.x * this.x + this.y * this.y;
    }

    public dotProduct(other: Point): number {
        return this.x * other.x + this.y * other.y;
    }

    public dotProductScalar(otherX: number, otherY: number) {
        return this.x * otherX + this.y * otherY;
    }

    /**
     * Compute the Z coordinate of the cross product of two vectors, to check if the second vector is
     * going clockwise ( > 0 ) or counterclockwise (< 0) compared with the first one. It could also be
     * 0, if the vectors are co-linear.
     */
    public clockwise(other: Point): boolean {
        return this.x * other.y - this.y * other.x > 0
    }

    public getDirection() {
        const d = this.getDistance()
        return this.div(d);
    }

    /**
     * Unary negation operator.
     *
     * Returns a Point with the coordinates negated.
     *
     * If the [Point] represents an arrow on a plane, this operator returns the same arrow but pointing
     * in the reverse direction.
     */
    public negate(): Point {
        return new Point(-this.x, -this.y);
    }

    /**
     * Binary subtraction operator.
     *
     * Returns a Point whose [x] value is the left-hand-side operand's [x] minus the right-hand-side
     * operand's [x] and whose [y] value is the left-hand-side operand's [y] minus the right-hand-side
     * operand's [y].
     */
    public minus(other: Point) {
        return new Point(this.x - other.x, this.y - other.y);
    }

    /**
     * Binary addition operator.
     *
     * Returns a Point whose [x] value is the sum of the [x] values of the two operands, and whose [y]
     * value is the sum of the [y] values of the two operands.
     */
    public plus(other: Point) {
        return new Point(this.x + other.x, this.y + other.y);
    }

    /**
     * Multiplication operator.
     *
     * Returns a Point whose coordinates are the coordinates of the left-hand-side operand (a Point)
     * multiplied by the scalar right-hand-side operand (a Float).
     */
    public times(operand: number) {
        return new Point(this.x * operand, this.y * operand)
    }

    /**
     * Division operator.
     *
     * Returns a Point whose coordinates are the coordinates of the left-hand-side operand (a Point)
     * divided by the scalar right-hand-side operand (a Float).
     */
    public div(operand: number) {
       return new Point(this.x / operand, this.y / operand);
    }

    /**
     * Modulo (remainder) operator.
     *
     * Returns a Point whose coordinates are the remainder of dividing the coordinates of the
     * left-hand-side operand (a Point) by the scalar right-hand-side operand (a Float).
     */
    public rem(operand: number) {
        return new Point(this.x % operand, this.y % operand);
    }

    /**
     * Linearly interpolate between two Points.
     *
     * The [fraction] argument represents position on the timeline, with 0.0 meaning that the
     * interpolation has not started, returning [start] (or something equivalent to [start]), 1.0
     * meaning that the interpolation has finished, returning [stop] (or something equivalent to
     * [stop]), and values in between meaning that the interpolation is at the relevant point on the
     * timeline between [start] and [stop]. The interpolation can be extrapolated beyond 0.0 and 1.0, so
     * negative values and values greater than 1.0 are valid (and can easily be generated by curves).
     *
     * Values for [fraction] are usually obtained from an [Animation<Float>], such as an
     * `AnimationController`.
     */
    public static interpolate(start: Point, stop: Point, fraction: number) {
        return new Point(interpolate(start.x, stop.x, fraction), interpolate(start.y, stop.y, fraction))
    }

    public transformed(f: (x: number, y: number) => Point) {
        const result = f(this.x, this.y);
        return new Point(result.x, result.y);
    }

    public rotate90() {
        return new Point(-this.y, this.x);
    }
}